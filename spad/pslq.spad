)abbrev package PSLQ Pslq
++ Author: Thomas Baruchel <baruchel@gmx.com>
++ Date: 2015/10/23
++ Description:
++   This is a spad version of the famous PSLQ algorithm by D.H. Bailey.
++   The code is adapted from a C++ example in the libqd package.
Pslq() : Exports == Implementation where

  Exports == with

    pslq : (Vector(Float), Float) -> Vector(Integer)
    ++ pslq(x, prec) returns an array of integer coefficients for detecting
    ++   an integer relation between real numbers from the array x.
    ++   Example:
    ++     digits(72)
    ++     z  := numeric( 4 + 3/2*%pi - %e)
    ++     v := vector([z, 1.0, %pi, %e])
    ++     pslq(v, 1.0E-36)
    ++         [- 2.0,8.0,3.0,- 2.0]
    setPslqMaxItr : PositiveInteger -> PositiveInteger
    ++ setPslqMaxItr(n) sets the maximum number of iterations allowed in the
    ++   PSLQ algorithm and returns the previous value for this setting.

  Implementation == add

      maxItr : PositiveInteger := 256
  
      setPslqMaxItr(n:PositiveInteger):PositiveInteger ==
        oldValue : PositiveInteger := maxItr
        maxItr := n
        oldValue
  
      pslq(x:Vector(Float), prec:Float):Vector(Integer) ==
        n : NonNegativeInteger := #x
        teps : Float := prec * 16.0
        gam : Float := 1.2
      
        -- Compute the vector s
        s : Vector(Float) := new(n, 0)
        s(n) := abs( x(n) )
        t : Float := x(n) * x(n)
        for i in (n-1)..1 by -1 repeat
          t := t + x(i) * x(i)
          s(i) := sqrt(t)
      
        -- Normalize the vector x, s
        t := s(1)
        y : Vector(Float) := new(n, 0)
        for i in 1..n repeat
          y(i) := x(i) / t
          s(i) := s(i) / t
      
        -- Construct matrix H, a, b
        h: Matrix Float := new(n, (n-1) ::PositiveInteger, 0)
        a: Matrix Integer := new(n, n, 0)
        b: Matrix Integer := new(n, n, 0)
        for i in 1..n repeat
          a(i,i) := 1; b(i,i) := 1
          for j in 1..min(i,n-1) repeat
            h(i,j) := if i=j then s(j+1) / s(j) _
                             else - y(i) * y(j) / (s(j) * s(j+1) )
      
        -- Reduce matrix H
        u : Integer
        for i in 2..n repeat
          for j in (i-1)..1 by -1 repeat
            t := round( h(i,j) / h(j,j) )
            u := retract(t)@Integer
            y(j) := y(j) + t * y(i)
            for k in 1..j repeat h(i,k) := h(i,k) - t * h(j,k)
            for k in 1..n repeat
              a(i,k) := a(i,k) - u * a(j,k)
              b(k,j) := b(k,j) + u * b(k,i)
      
        m : NonNegativeInteger
        m_val : Float
        g: Float
        itr : NonNegativeInteger := 0
      
        while itr < maxItr repeat
          m_val := -1
          g := gam
      
          for i in 1..(n-1) repeat
            t := abs( g * h(i,i) )
            if t > m_val then ( m_val := t; m := i )
            g := g * gam
      
          swap!(y, m, m+1)
          swapRows!(a, m, m+1)
          swapRows!(h, m, m+1)
          swapColumns!(b, m, m+1)
      
          if m < n-1 then
            t0 : Float := sqrt( h(m,m)^2 + h(m,m+1)^2 )
            t1 : Float := h(m,m) / t0
            t2 : Float := h(m,m+1) / t0
            for i in m..n repeat
              t3 : Float := h(i,m)
              t4 : Float := h(i,m+1)
              h(i,m) := t1*t3 + t2*t4
              h(i,m+1) := t1*t4 - t2*t3
      
          for i in (m+1)..n repeat
            for j in min(i-1,m+1)..1 by -1 repeat
              t := round( h(i,j)/h(j,j) )
              u := retract(t)@Integer
              y(j) := y(j) + t * y(i)
              for k in 1..j repeat h(i,k) := h(i,k) - t * h(j,k)
              for k in 1..n repeat
                a(i,k) := a(i,k) - u * a(j,k)
                b(k,j) := b(k,j) + u * b(k,i)
      
          m_val := 1.0E-308
          for j in 1..(n-1) repeat
            t := abs( h(j,j) )
            if t > m_val then m_val := t
      
          for i in 1..n repeat
            t := abs( y.i )
            if t < teps then
              m := i
              return column(b,m)
      
          itr := itr + 1

        new(n,0)
