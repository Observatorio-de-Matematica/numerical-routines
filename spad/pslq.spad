)abbrev package PSLQ Pslq
++ Author: Thomas Baruchel <baruchel@gmx.com>
++ Date: 2015/10/23
++ Description:
++   This is a spad version of the famous PSLQ algorithm by D.H. Bailey.
++   The code is adapted from a C++ example in the libqd package.
Pslq : with _
  pslq : (OneDimensionalArray(Float), Float) -> OneDimensionalArray(Float)
  ++ pslq(x, prec) returns an array of integer coefficients for detecting
  ++   a relation between real numbers from the array x.
  ++   Example:
  ++     digits(72)
  ++     z  := numeric( 4 + 3/2*%pi - %e)
  ++     v := oneDimensionalArray([z, 1.0, %pi, %e])
  ++     pslq(v, 1.0E-36)
  ++         [- 2.0,8.0,3.0,- 2.0]
  == add
    pslq(x:OneDimensionalArray(Float), prec:Float):OneDimensionalArray(Float) ==
      n : NonNegativeInteger := #x
      teps : Float := prec * 16.0
      gam : Float := 1.2
    
      ++ Compute the vector s
      s : OneDimensionalArray(Float) := new(n, 0)
      s.n := abs( x.n )
      t : Float := x.n * x.n
      for i in (n-1)..1 by -1 repeat
        t := t + x.i * x.i
        s.i := sqrt(t)
    
      ++ Normalize the vector x, s
      t := s.1
      y : OneDimensionalArray(Float) := new(n, 0)
      for i in 1..n repeat
        y.i := x.i / t
        s.i := s.i / t
    
      ++ Construct matrix H, a, b
      h: TwoDimensionalArray Float := new(n, (n-1) pretend PositiveInteger, 0.0)
      a: TwoDimensionalArray Float := new(n, n, 0.0)
      b: TwoDimensionalArray Float := new(n, n, 0.0)
      for i in 1..n repeat
        a(i,i) := 1.0; b(i,i) := 1.0
        for j in 1..min(i,n-1) repeat
          h(i,j) := if i=j then s.(j+1) / s.j _
                           else - y.i * y.j / (s.j * s.(j+1) )
    
      ++ Reduce matrix H
      for i in 2..n repeat
        for j in (i-1)..1 by -1 repeat
          t := round( h(i,j) / h(j,j) )
          y.j := y.j + t * y.i
          for k in 1..j repeat h(i,k) := h(i,k) - t * h(j,k)
          for k in 1..n repeat
            a(i,k) := a(i,k) - t * a(j,k)
            b(k,j) := b(k,j) + t * b(k,i)
    
      m : NonNegativeInteger
      done: Boolean := false
      m_val : Float
      g: Float
    
      while not done repeat
        m_val := -1.0
        g := gam
    
        for i in 1..(n-1) repeat
          t := abs( g * h(i,i) )
          if t > m_val then ( m_val := t; m := i )
          g := g * gam
    
        swap!(y, m, m+1)
        swapRows!(a, m, m+1)
        swapRows!(h, m, m+1)
        swapColumns!(b, m, m+1)
    
        if m < n-1 then
          t0 : Float := sqrt( h(m,m)^2 + h(m,m+1)^2 )
          t1 : Float := h(m,m) / t0
          t2 : Float := h(m,m+1) / t0
          for i in m..n repeat
            t3 : Float := h(i,m)
            t4 : Float := h(i,m+1)
            h(i,m) := t1*t3 + t2*t4
            h(i,m+1) := t1*t4 - t2*t3
    
        for i in (m+1)..n repeat
          for j in min(i-1,m+1)..1 by -1 repeat
            t := round( h(i,j)/h(j,j) )
            y.j := y.j + t * y.i
            for k in 1..j repeat h(i,k) := h(i,k) - t * h(j,k)
            for k in 1..n repeat
              a(i,k) := a(i,k) - t * a(j,k)
              b(k,j) := b(k,j) + t * b(k,i)
    
        m_val := 1.0E-308
        for j in 1..(n-1) repeat
          t := abs( h(j,j) )
          if t > m_val then m_val := t
    
        for i in 1..n repeat
          t := abs( y.i )
          if t < teps then
            m := i
            done := true
            break
    
      column(b, m)
